#!/usr/bin/env python

import rospy
from nav_msgs.msg import Odometry
from nav_msgs.msg import OccupancyGrid
from sensor_msgs.msg import LaserScan
from tf.transformations import euler_from_quaternion
import tf2_ros as tf
from geometry_msgs.msg import Twist
from std_msgs.msg import String
import math
import cmath
import numpy as np
import time
from visualization_msgs.msg import Marker
from nav_class import Navigation

import cv2
from cv_bridge import CvBridge, CvBridgeError

laser_range = np.array([])
occdata = []

yaw = 0.0
rotate_speed = 1.0
linear_speed = 0.5
stop_distance = 0.25

occ_bins = [-1, 0, 100, 101]
front_angle = 30
front_angles = range(-front_angle, front_angle+1, 1)

occ_grid = []
bot_pos = ()
checked_positions = []
map_height = 0
map_width = 0

navigator = Navigation(linear_speed, rotate_speed)

def odom_cb(msg):
	global yaw

	orientation_quat = msg.pose.pose.orientation
	orientation_list = [orientation_quat.x, orientation_quat.y, orientation_quat.z, orientation_quat.w]
	(roll, pitch, yaw) = euler_from_quaternion(orientation_list)
	navigator.update_yaw(yaw)

def laser_scan_cb(msg):
	global laser_range
	laser_range = np.array([msg.ranges])
	navigator.update_laserscan_data(laser_range)

def occ_cb(msg, tf_buf):
	global occdata
	global bot_pos
	global occ_grid

	occdata = np.array([msg.data])
	occ_counts = np.histogram(occdata, occ_bins)
	total_bins = msg.info.width * msg.info.height

	rospy.loginfo('Unmapped: %i, Unoccupied: %i, Occupied: %i, Total: %i', occ_counts[0][0], occ_counts[0][1], occ_counts[0][2], total_bins)

	trans2 = tf_buf.lookup_transform('map', 'base_link', rospy.Time(0))
	cur_pos = trans2.transform.translation
	map_res = msg.info.resolution
	map_origin = msg.info.origin.position
	grid_x = int((cur_pos.x - map_origin.x)/map_res)
	grid_y = int((cur_pos.y - map_origin.y)/map_res)
	bot_pos = (grid_x, grid_y)
	rospy.loginfo('[NAV] current position: %s', str(bot_pos))

	oc2 = occdata + 1
	occ_grid = np.uint8(oc2.reshape(msg.info.height, msg.info.width, order='F'))

	navigator.update_bot_pos((bot_pos[1],bot_pos[0]))
	navigator.update_occ_grid(occ_grid, map_origin)

def stopbot():
    # publish to cmd_vel to move TurtleBot
    pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)

    twist = Twist()
    twist.linear.x = 0.0
    twist.angular.z = 0.0
    time.sleep(1)
    pub.publish(twist)

def mapper():
	rospy.init_node('mapper', anonymous=True)

	tf_buf = tf.Buffer()
	tf_listener = tf.TransformListener(tf_buf)
	rospy.sleep(1.0)

	rospy.Subscriber('odom', Odometry, odom_cb)
	rospy.Subscriber('scan', LaserScan, laser_scan_cb)
	rospy.Subscriber('map', OccupancyGrid, occ_cb, tf_buf)

	rospy.on_shutdown(stopbot)
	rospy.sleep(3)

	# navigator.rotate_bot(math.degrees(10))
	# time.sleep(1)
	# navigator.rotate_bot(math.degrees(-10))
	# time.sleep(1)

	# navigator.display_map()
	navigator.test_func('')

	# navigator.map_region()
	# navigator.test_func("")
	# navigator.rotate_bot(360)
	# rate = rospy.Rate(5)
	# while not navigator.mapping_complete():
	# 	navigator.get_nearest_unmapped_region()
	# 	navigator.set_target()
	# 	# navigator.set_marker()
	# 	# navigator.move_to_target()
	# 	target = navigator.get_next_target()
	# 	angle = navigator.get_direction(target)
	# 	navigator.rotate_bot(angle)
	# 	navigator.display_map()
	# 	navigator.move_bot(linear_speed, 0.0)
	# 	rate.sleep()
		

	rospy.spin()

if __name__ == '__main__':
	try:
		mapper()
	except rospy.ROSInterruptException:
		exit()
	except KeyboardInterrupt:
		exit()